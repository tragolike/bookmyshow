
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://gfmxvjxgjswbxbtkseap.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdmbXh2anhnanN3YnhidGtzZWFwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM1OTg2OTEsImV4cCI6MjA1OTE3NDY5MX0.ajBWfE7Ici2KiCBL3Hnl24ocJS4-1MZLX8ehvHX9b6c";

// Define our custom Database interface that matches our actual Supabase schema
export type Tables = Database['public']['Tables']

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Add a typed helper function to make working with the database easier
export const db = {
  profiles: () => supabase.from('profiles'),
  events: () => supabase.from('events'),
  movies: () => supabase.from('movies'),
  bookings: () => supabase.from('bookings'),
  // For cities and countries, we need proper type definitions
  cities: () => supabase.from('cities') as any,
  countries: () => supabase.from('countries') as any,
  // Add the new tables with proper type casting until types are generated
  seatLayouts: () => supabase.from('seat_layouts') as any,
  paymentSettings: () => supabase.from('payment_settings') as any
};

// Type definitions for common data types
export type BookingStatus = 'confirmed' | 'pending' | 'cancelled';
export type PaymentStatus = 'completed' | 'pending' | 'failed';
export type EventStatus = 'fast-filling' | 'sold-out' | 'available';
export type UserRole = 'admin' | 'user';

// Helper function to get event by ID - centralized logic to prevent 404 errors
export const getEventById = async (id: string) => {
  try {
    const { data, error } = await db.events()
      .select('*')
      .eq('id', id)
      .single();
      
    if (error) throw error;
    return { data, error: null };
  } catch (error) {
    console.error('Error fetching event by ID:', error);
    return { data: null, error };
  }
};

// Helper function to get events by city - to fix city-based filtering
export const getEventsByCity = async (city: string) => {
  try {
    const { data, error } = await db.events()
      .select('*')
      .eq('city', city);
      
    if (error) throw error;
    return { data, error: null };
  } catch (error) {
    console.error('Error fetching events by city:', error);
    return { data: null, error };
  }
};

// Helper function to get latest events - for homepage
export const getLatestEvents = async (limit = 6) => {
  try {
    const { data, error } = await db.events()
      .select('*')
      .order('created_at', { ascending: false })
      .limit(limit);
      
    if (error) throw error;
    return { data, error: null };
  } catch (error) {
    console.error('Error fetching latest events:', error);
    return { data: null, error };
  }
};

// For now - hardcoded admin emails since we don't have a roles table
// In a real app, this would be stored in a database table
const ADMIN_EMAILS = ['admin@showtix.com', 'admin@example.com', 'ritikpaswal79984@gmail.com'];

// Helper function to check if a user is an admin
export const isUserAdmin = (email: string | undefined): boolean => {
  if (!email) return false;
  return ADMIN_EMAILS.includes(email.toLowerCase());
};

// Helper function to get payment settings
export const getPaymentSettings = async () => {
  try {
    const { data, error } = await db.paymentSettings()
      .select('*')
      .single();
      
    if (error) throw error;
    return { data, error: null };
  } catch (error) {
    console.error('Error fetching payment settings:', error);
    return { data: null, error };
  }
};

// Helper function to update payment settings with proper typing
export const updatePaymentSettings = async (updates: { upi_id?: string; qr_code_url?: string }) => {
  try {
    const { data: currentSettings } = await getPaymentSettings();
    
    if (!currentSettings) {
      throw new Error("Payment settings not found");
    }
    
    const { data, error } = await db.paymentSettings()
      .update(updates as any)
      .eq('id', currentSettings.id)
      .select()
      .single();
      
    if (error) throw error;
    return { data, error: null };
  } catch (error) {
    console.error('Error updating payment settings:', error);
    return { data: null, error };
  }
};

// Helper function to get seat layout by event ID
export const getSeatLayoutByEventId = async (eventId: string) => {
  try {
    const { data, error } = await db.seatLayouts()
      .select('*')
      .eq('event_id', eventId)
      .single();
      
    if (error && error.code !== 'PGRST116') throw error; // Ignore "No rows returned" error
    return { data, error: null };
  } catch (error) {
    console.error('Error fetching seat layout:', error);
    return { data: null, error };
  }
};

// Helper function to create or update seat layout with proper typing
export const upsertSeatLayout = async (eventId: string, layoutData: any) => {
  try {
    // Check if layout exists
    const existing = await getSeatLayoutByEventId(eventId);
    
    if (existing.data) {
      // Update existing layout
      const { data, error } = await db.seatLayouts()
        .update({ 
          layout_data: layoutData,
          updated_at: new Date().toISOString()
        } as any)
        .eq('id', existing.data.id)
        .select()
        .single();
        
      if (error) throw error;
      return { data, error: null, isNew: false };
    } else {
      // Create new layout
      const { data, error } = await db.seatLayouts()
        .insert({ 
          event_id: eventId,
          layout_data: layoutData
        } as any)
        .select()
        .single();
        
      if (error) throw error;
      return { data, error: null, isNew: true };
    }
  } catch (error) {
    console.error('Error upserting seat layout:', error);
    return { data: null, error, isNew: false };
  }
};
